{
  parserClass="lang.dragonbook.language.psi.parser.DragonBookParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="DragonBook"
  psiImplClassSuffix="Impl"
  psiPackage="lang.dragonbook.language.psi"
  psiImplPackage="lang.dragonbook.language.psi.impl"

  elementTypeHolderClass="lang.dragonbook.language.psi.DragonBookTypes"
  elementTypeClass="lang.dragonbook.language.psi.DragonBookElementType"
  tokenTypeClass="lang.dragonbook.language.psi.DragonBookTokenType"

  psiImplUtilClass="lang.dragonbook.language.psi.DragonBookPsiImplUtil"

  extends(".*Expr")=expression

  tokens=[
    // Fake tokens to generate parser types
    COMMENT = 'comment'
    BAD_CHARACTER = 'bad_char'
  ]
}

program ::= function+

function ::= annotations? FUN functionName LPAR functionParameters? RPAR (ARROW type)? block { pin=2 recoverWhile=function_recover }
private function_recover ::= !(FUN | HASH)

functionName ::= ID

annotations ::= HASH LBRACKET annotationList? RBRACKET { pin=1 }

annotationList ::= ID (COMMA ID)*

functionParameters ::= functionParameter (COMMA functionParameter)*

functionParameter ::= type ID

statement ::= declaration end
            | assignment end
            | functionCall end
            | breakStatement
            | continueStatement
            | returnStatement
            | ifStatement
            | whileStatement
            | doWhileStatement
            | forStatement
            | block

functionCall ::= ID LPAR callArguments? RPAR { pin=2 }

callArguments ::= expression (COMMA expression)*

block ::= LBRACE statement* RBRACE { pin=1 }

declaration ::= type varName (ASSIGN expression)? { pin=2 }

varName ::= ID {
    mixin="lang.dragonbook.language.psi.DragonBookNamedElementImpl"
    implements="lang.dragonbook.language.psi.DragonBookNamedElement"
    methods=[getName setName getNameIdentifier]
}

type ::= ID (STAR)*

assignment ::= lvalue assignOp expression { pin=2 }

assignOp ::= ASSIGN | PLUS_ASSIGN | MINUS_ASSIGN | STAR_ASSIGN | DIV_ASSIGN | MOD_ASSIGN

lvalue ::= idLValue | derefLValue

idLValue ::= ID

derefLValue ::= STAR expression

ifStatement ::= IF LPAR expression RPAR statement (ELSE statement)? { pin=1 }

whileStatement ::= WHILE LPAR expression RPAR statement { pin=1 }

doWhileStatement ::= DO statement WHILE LPAR expression RPAR end { pin=1 }

forStatement ::= FOR LPAR (declaration | assignment)? SEMICOLON expression? SEMICOLON assignment? RPAR statement { pin=1 }

breakStatement ::= BREAK end { pin=1 }

continueStatement ::= CONTINUE end { pin=1 }

returnStatement ::= RETURN expression? end { pin=1 }

expression ::= orExpr
             | andExpr
             | comparisonExpr
             | addSubExpr
             | mulDivExpr
             | castExpr
             | unaryExpr
             | callExpr
             | idExpr
             | trueExpr
             | falseExpr
             | intExpr
             | floatExpr
             | parenExpr

orExpr ::= expression OR expression

andExpr ::= expression AND expression

comparisonExpr ::= expression comparisonOp expression

addSubExpr ::= expression (PLUS | MINUS) expression

mulDivExpr ::= expression (STAR | DIV | MOD) expression

castExpr ::= expression AS type

unaryExpr ::= (MINUS | NOT | STAR) expression

parenExpr ::= LPAR expression RPAR { pin=1 }

idExpr ::= ID {
    methods=[getReference]
}

trueExpr ::= TRUE

falseExpr ::= FALSE

intExpr ::= INT_LITERAL

floatExpr ::= FLOAT_LITERAL

callExpr ::= functionCall

comparisonOp ::= LESS | GREATER | LESS_EQUAL | GREATER_EQUAL | EQUAL | NOT_EQUAL

private end ::= SEMICOLON